public class Main{
  public static void Main (String[] args ){
    List<String> ciudades = New arrayList<>();
    
    ciudades.add("la plata");
    ciudades.add("buenos aires");
    ciudades.add("chivilcoy");
    ciudades.add("chascomus");
    ciudades.add("gomez");
    ciudades.add("ensenada");
    ciudades.add("beriso");
    ciudades.add("punta lara");
    
    // manera 1 de hacer el recorrido con stream, aca con lambda
    ciudades.stream().forEach(ciudad -> System.out.println(ciudad));
    
    // manera 2 de hacer recorrido con stream, en este caso le pasamos la funcion de abajo y no usamos lambda
    ciudades.stream().forEach(Main::printCiudad); 
    // los :: es pq la funcion que invocamos es static (referencia a metodo se llama, se introdujo en java 8)
    
    // manera 3 con un forEach y referencia, es decir una combinacion de la manera 1 y 2
    ciudades.stream().forEach(System.out::println);
    
    // manera 4 concurrencia. agregando el comando parallel usamos varios nucleos del procesador
    ciudades.stream().parallel().forEach(System.out::println);
    
    
    // filtrar textos con stream y lambda (en cada . del stream se puede dar enter para ordenar)
    ciudades.strem().filter(ciudad -> ciudad.startwith("b"))
      .filter(ciudad -> ciudad.contains("a")) // filtramos las ciudades que contengan la letra "a"
      .forEach(System.out::println); // filtramos las ciudades con letra "b" 
     
    
  }
  
  // si encuentra lo que buscamos devuelve true
  public static boolean BooleanoSiEncuentra (String city){
    return ciudad.startwith("b");
  }
  
  // simplemente se usa para imprimir
  public static void printCiudad (String city){
    System.out.println(city);
  }
}
